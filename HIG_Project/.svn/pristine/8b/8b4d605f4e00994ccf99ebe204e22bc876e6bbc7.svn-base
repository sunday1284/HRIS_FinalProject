package kr.or.ddit.qr.controller;

import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.imageio.ImageIO;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import kr.or.ddit.annual.service.AnnualHistoryService;
import kr.or.ddit.annual.vo.AnnualHistoryVO;
import kr.or.ddit.attendance.service.AttendanceService;
import kr.or.ddit.attendance.vo.AttendanceVO;
import kr.or.ddit.qr.service.QrService;
import kr.or.ddit.qr.vo.QrVO;
import lombok.extern.slf4j.Slf4j;
/**
 * 
 * 
 * @author ì •íƒœìš°
 * @since 2025. 3. 14.
 * @see
 *
 * <pre>
 * << ê°œì •ì´ë ¥(Modification Information) >>
 *   
 *   ìˆ˜ì •ì¼      			ìˆ˜ì •ì           ìˆ˜ì •ë‚´ìš©
 *  -----------   	-------------    ---------------------------
 *  2025. 3. 12.     	ì •íƒœìš°	          ìµœì´ˆ ìƒì„±
 *
 * </pre>
 */
@Controller
@Slf4j
@RequestMapping("/")
public class QRCodeController {
	

	
	private SecretKey secretKey;
	
	@Autowired
	private AnnualHistoryService AHservice;
	
	@Autowired
	private AttendanceService service;
	
	@Autowired
	private QrService qrservice;
	
    @Autowired
    private QrWebSocket qrWebSocket;
    
    /**
     * QRìŠ¤ìº”ì‹œ ë“¤ì–´ì˜¤ëŠ” ë©”ì„œë“œ 
     * @param token
     * @param model
     * @return
     */
	@GetMapping("qrqr")
	public ResponseEntity<String> locationQR(@RequestParam("token") String token) {
		try {
			// 1. QR ì½”ë“œ ìœ íš¨ì„± ê²€ì‚¬
			QrVO qrInfo = qrservice.getQRInfo(token);
			if (qrInfo == null)
				throw new RuntimeException("ìœ íš¨í•˜ì§€ ì•Šì€ QR ì½”ë“œ ì…ë‹ˆë‹¤.");

			LocalDateTime now = LocalDateTime.now();
			String empId = qrInfo.getEmpId();
			String expiresAt = qrInfo.getExpiresAt();
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
			LocalDateTime expirationTime = LocalDateTime.parse(expiresAt, formatter);

			// 2. QR ì½”ë“œ ë§Œë£Œ ì—¬ë¶€ í™•ì¸
			if (expirationTime.isBefore(now))
				throw new RuntimeException("QR ì½”ë“œê°€ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");

			// 3. ì˜¤ëŠ˜ì˜ ì¶œê·¼ ê¸°ë¡ ì¡°íšŒ
			AttendanceVO existingAttendance = service.findTodayAttendance(empId);
			
			DateTimeFormatter formatterDate = DateTimeFormatter.ofPattern("yyyy-MM-dd");
			DateTimeFormatter formatterTime = DateTimeFormatter.ofPattern("HH:mm:ss");
			String formattedDate = now.format(formatterDate);
			String formattedTime = now.format(formatterTime);

			String message;
			if (existingAttendance != null) {
				// í‡´ê·¼ ì²˜ë¦¬
				existingAttendance.setWorkEndTime(formattedTime);
				existingAttendance.setStatusId("STAT_03");
				service.updateWorkEnd(existingAttendance);
				message = "í‡´ê·¼ì´ ì •ìƒì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.";
			} else {
				// ì¶œê·¼ ì²˜ë¦¬
				AttendanceVO attendance = new AttendanceVO();
				LocalDate today = LocalDate.now();
				String attendanceStatus = "ì •ìƒ"; // ê¸°ë³¸ê°’
				boolean isMorningLeave = false;

				// í•œ ì§ì›ì˜ ì—°ì°¨ ê¸°ë¡ ëª©ë¡
				List<AnnualHistoryVO> empHistoryList = AHservice.EmpHisrotyDetail(qrInfo.getEmpId());
				// ì˜¤ëŠ˜ì ì—°ì°¨ê°€ ìˆìœ¼ë©´ì„œ ê·¸ê²Œ ì˜¤ì „ë°˜ì°¨ì¼ë•Œ ì •ìƒ ë° ì˜¤ì „ë°˜ì°¨ ì²´í¬
				for (AnnualHistoryVO empHistory : empHistoryList) {
					DateTimeFormatter formatterDateTime = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
					LocalDateTime leaveDateTime = LocalDateTime.parse(empHistory.getLeaveDate(), formatterDateTime);
					LocalDate leaveDateL = leaveDateTime.toLocalDate();
					
					if (today.equals(leaveDateL) && "AC_10".equals(empHistory.getAnnualCode())) { 
						isMorningLeave = true;
						break;
					}
				}
				// ì¶œê·¼ ìƒíƒœ ê²°ì •
				if (isMorningLeave) {
					attendanceStatus = now.toLocalTime().isBefore(LocalTime.of(13, 1)) ? "ì˜¤ì „ë°˜ì°¨" : "ì§€ê°";
				} else {
					attendanceStatus = now.toLocalTime().isBefore(LocalTime.of(9, 1)) ? "ì •ìƒ" : "ì§€ê°";
				}
				// ê³µí†µ ì¶œê·¼ ì²˜ë¦¬
				attendance.setEmpId(empId);
				attendance.setWorkDate(formattedDate);
				attendance.setWorkStartTime(formattedTime);
				attendance.setAttendanceStatus(attendanceStatus);
				attendance.setStatusId("STAT_01");
				service.attendanceInsert(attendance);
				message = "ì¶œê·¼ì´ ì •ìƒì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.";
			}
			// ê³µí†µ í›„ì²˜ë¦¬
			qrservice.deleteQR(token);
			qrWebSocket.sendMessageToUser(empId, message);
			
			String script = "<script> window.close();</script>";
			return ResponseEntity.ok().contentType(MediaType.TEXT_HTML).body(script);
		} catch (Exception e) {
			// 6. ì˜ˆì™¸ ë°œìƒ ì‹œ ì—ëŸ¬ ë©”ì‹œì§€ ë°˜í™˜
			String errorScript = "<script>alert('ì˜¤ë¥˜ ë°œìƒ: " + e.getMessage() + "'); window.close();</script>";
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).contentType(MediaType.TEXT_HTML).body(errorScript);
		}
	}

	
	/**
	 * QRì„ ë§Œë“¤ì–´ì£¼ê³  ê·¸ ì•ˆì— ë™ì ì¸ IPì™€ í† í°ì„ ë§Œë“¤ì–´ì¤Œ
	 * @param model
	 * @param session
	 * @param req
	 * @return
	 * @throws Exception
	 */
	@GetMapping("generate-qr")
	public String generateQRCode(Model model, HttpSession session, HttpServletRequest req) throws Exception {
	    Authentication account = SecurityContextHolder.getContext().getAuthentication();
	    // ë¡œê·¸ì¸ëœ ì‚¬ìš©ì ID
	    String empId = account.getName(); 
	    
	    LocalDate today = LocalDate.now();
	    
	    // í•œ ì§ì›ì˜ ì—°ì°¨ ê¸°ë¡ ëª©ë¡
		List<AnnualHistoryVO> empHistoryList = AHservice.EmpHisrotyDetail(empId);
		
		boolean isOnLeave = false; // ì—°ì°¨ ì—¬ë¶€ ì²´í¬ ë³€ìˆ˜
		
		// ì˜¤ëŠ˜ì´ ì—°ì°¨ê¸°ë¡ì— ìˆë‹¤ë©´ QR ìƒì„± ë¶ˆê°€ return
		for (AnnualHistoryVO empHistory : empHistoryList) {
			DateTimeFormatter formatterDateTime = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
			LocalDateTime leaveDateTime = LocalDateTime.parse(empHistory.getLeaveDate(), formatterDateTime);
			LocalDate leaveDateL = leaveDateTime.toLocalDate();
			
			// ì˜¤ëŠ˜ ë‚ ì§œê°€ ì—°ì°¨ ê¸°ë¡ì— í¬í•¨ë˜ì–´ ìˆê³ , ì—°ì°¨ ì½”ë“œê°€ "AC_10" ë˜ëŠ” "AC_11"ì´ ì•„ë‹Œ ê²½ìš°
		    if (today.equals(leaveDateL) && !("AC_10".equals(empHistory.getAnnualCode()) || "AC_11".equals(empHistory.getAnnualCode()))) { 
		        isOnLeave = true; // ì—°ì°¨ê°€ ìˆëŠ” ê²½ìš° (íœ´ê°€)
		        break; // ë” ì´ìƒ ë°˜ë³µë¬¸ì„ ëŒì§€ ì•Šê³  ë¹ ì ¸ë‚˜ì˜µë‹ˆë‹¤.
		    }		
		}
		
		if (isOnLeave) {
			String message = "ì—°ì°¨ì¸ ì§ì›ì€ QRìŠ¤ìº” ë¶ˆê°€.";
//			qrWebSocket.sendMessageToUser(empId, message);
			 model.addAttribute("qrAlertMessage", message);
		    return "qr/NotQr";
		}
	    // QR ë§Œë£Œ ì‹œê°„ ( 5ë¶„ í›„ ë§Œë£Œ )
	    LocalDateTime expiresAt = LocalDateTime.now().plusMinutes(5);
	    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
	    String formattedExpireAt = expiresAt.format(formatter);
	    
	    // empIDì™€ ë§Œë£Œê¸°í•œì„ ë§µì— ë“±ë¡
	    Map<String, Object> claims = new HashMap<>();
	    claims.put("empId", empId);
	    claims.put("formattedExpireAt", formattedExpireAt);
	    
	    // HmacSHA256 ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë¹„ë°€ í‚¤ ìƒì„±
	    secretKey = createSecretKey();
	    String token = Jwts.builder()
	    		.setClaims(claims)
	    	    .setExpiration(new Date(System.currentTimeMillis() + (5 * 60 * 1000))) // 5ë¶„ í›„ ë§Œë£Œ
	    	    .signWith(SignatureAlgorithm.HS256, secretKey.getEncoded()) // byte[]ë¡œ ë³€í™˜ëœ ë¹„ë°€í‚¤ ì‚¬ìš©
	    	    .compact();
	    
	    // DBì— QR ì •ë³´ ì €ì¥ 
	    qrservice.saveQR(token, empId, formattedExpireAt);
	    
	    // ì„œë²„ IP ê°€ì ¸ì˜¤ê¸°
	    String ip = getIp();
	    
	    // QRì— ë„£ì–´ì¤„ ë§í¬ ë°ì´í„° 
	    String qrData = "https://" + ip + req.getContextPath() + "/qrqr?token=" + token + "&autoClose=true";
	    try {
	        int size = 400; // QR ì½”ë“œ ì‚¬ì´ì¦ˆ 
	        QRCodeWriter qrCodeWriter = new QRCodeWriter();
	        Hashtable<EncodeHintType, Object> hints = new Hashtable<>();
	        hints.put(EncodeHintType.MARGIN, 1); // QR ì½”ë“œ ì—¬ë°± ì„¤ì •

	        // QR ë°ì´í„°ë¡œ QR ì½”ë“œ ìƒì„±
	        BitMatrix bitMatrix = qrCodeWriter.encode(qrData, BarcodeFormat.QR_CODE, size, size, hints);

	        // BitMatrixë¥¼ BufferedImageë¡œ ë³€í™˜
	        BufferedImage bufferedImage = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);
	        for (int x = 0; x < size; x++) {
	            for (int y = 0; y < size; y++) {
	                bufferedImage.setRGB(x, y, (bitMatrix.get(x, y)) ? 0x000000 : 0xFFFFFF); // ê²€ì •ê³¼ í°ìƒ‰ìœ¼ë¡œ ì„¤ì •
	            }
	        }
	        
	        // ì´ë¯¸ì§€ë¥¼ ByteArrayë¡œ ë³€í™˜í•˜ì—¬ Base64ë¡œ ì¸ì½”ë”©
	        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
	        ImageIO.write(bufferedImage, "PNG", byteArrayOutputStream);
	        byte[] qrImageBytes = byteArrayOutputStream.toByteArray();
	        String qrCodeImage = "data:image/png;base64," + java.util.Base64.getEncoder().encodeToString(qrImageBytes);

	        // ëª¨ë¸ì— QR ì½”ë“œ ì´ë¯¸ì§€ ë°ì´í„° ì „ë‹¬
	        model.addAttribute("qrCode", qrCodeImage);
	        
	    } catch (Exception e) {
	        throw new RuntimeException(e);
	    }
	    return "qr/QRcode"; // ëª¨ë‹¬ë¡œ QRì½”ë“œë¥¼ ëœë”ë§ í•  JSP
	}
	
	// ë¹„ë°€ í‚¤ ìƒì„± ë©”ì†Œë“œ (HmacSHA256 ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©)
	private SecretKey createSecretKey() throws Exception {
	    KeyGenerator keyGenerator = KeyGenerator.getInstance("HmacSHA256");
	    keyGenerator.init(256); // í‚¤ í¬ê¸° ì„¤ì • (256ë¹„íŠ¸)
	    return keyGenerator.generateKey();
	}
	private static final  String IP_PREFIX = "192.168.";  // ì›í•˜ëŠ” ip ëŒ€ì—­ ì„¤ì •
	
	public String getIp() throws SocketException {
	    String wifiIp = null;

	    for (NetworkInterface netIf : Collections.list(NetworkInterface.getNetworkInterfaces())) {
	        String name = netIf.getName().toLowerCase();
	        String displayName = netIf.getDisplayName().toLowerCase();

	        // ğŸš« ê°€ìƒ ì–´ëŒ‘í„° í•„í„°ë§ (displayNameì— ê¸°ë°˜)
	        if (displayName.contains("vethernet") || displayName.contains("wsl") ||
	            displayName.contains("hyper-v") || displayName.contains("virtual") ||
	            displayName.contains("docker") || displayName.contains("nat") ||
	            displayName.contains("vmnet") || displayName.contains("loopback") ||
	            displayName.contains("br-")) {
	            continue;
	        }

	        for (InetAddress addr : Collections.list(netIf.getInetAddresses())) {
	            if (addr instanceof Inet4Address && !addr.isLoopbackAddress()) {
	                String ip = addr.getHostAddress();

	                // ğŸ§  ìœ ì„  ìš°ì„ , IP ëŒ€ì—­ë„ í•„í„°ë§
	                if (ip.startsWith(IP_PREFIX) || ip.startsWith("10.") || ip.matches("172\\.(1[6-9]|2[0-9]|3[0-1])\\..*")) {
	                    if (name.startsWith("eth") || name.startsWith("en") || name.startsWith("ens")) {
	                        return ip;
	                    }
	                    if (name.startsWith("wlan") || name.startsWith("wi") || name.contains("wifi")) {
	                        wifiIp = ip;
	                    }
	                }
	            }
	        }
	    }

	    return wifiIp; // ìœ ì„ ì´ ì—†ìœ¼ë©´ ë¬´ì„  ë°˜í™˜
	}
}
